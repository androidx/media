/*
 * Copyright 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package androidx.media3.transformer;

import static androidx.media3.common.PlaybackException.ERROR_CODE_IO_FILE_NOT_FOUND;
import static androidx.media3.common.PlaybackException.ERROR_CODE_SETUP_REQUIRED;
import static androidx.media3.exoplayer.SeekParameters.CLOSEST_SYNC;
import static androidx.media3.exoplayer.SeekParameters.NEXT_SYNC;
import static androidx.media3.test.utils.BitmapPixelTestUtil.maybeSaveTestBitmap;
import static androidx.media3.test.utils.BitmapPixelTestUtil.readBitmap;
import static androidx.media3.test.utils.TestUtil.assertBitmapsAreSimilar;
import static androidx.media3.transformer.AndroidTestUtil.MP4_ASSET;
import static androidx.media3.transformer.AndroidTestUtil.MP4_TRIM_OPTIMIZATION_270;
import static androidx.media3.transformer.AndroidTestUtil.assumeFormatsSupported;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.junit.Assert.assertThrows;

import android.app.Instrumentation;
import android.content.Context;
import android.graphics.Bitmap;
import androidx.media3.common.MediaItem;
import androidx.media3.common.PlaybackException;
import androidx.media3.common.util.ConditionVariable;
import androidx.media3.common.util.NullableType;
import androidx.media3.effect.Presentation;
import androidx.media3.exoplayer.ExoPlaybackException;
import androidx.media3.transformer.ExperimentalFrameExtractor.Frame;
import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import com.google.common.collect.ImmutableList;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicReference;
import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

/** End-to-end instrumentation test for {@link ExperimentalFrameExtractor}. */
@RunWith(AndroidJUnit4.class)
public class FrameExtractorTest {
  // Golden files are generated by MediaMetadataRetriever running on Pixel 8.
  private static final String GOLDEN_ASSET_FOLDER_PATH =
      "test-generated-goldens/FrameExtractorTest/";
  private static final String FILE_PATH =
      "asset:///media/mp4/sample_with_increasing_timestamps_360p.mp4";
  private static final long TIMEOUT_SECONDS = 20;
  // TODO: b/350498258 - Due to bugs in hardware decoders, we can only assert for low PSNR values.
  // Move to using software decoders in pixel tests, and increase PSNR threshold.
  private static final float PSNR_THRESHOLD = 25f;

  @Rule public final TestName testName = new TestName();

  private final Context context = ApplicationProvider.getApplicationContext();

  private String testId;
  private @MonotonicNonNull ExperimentalFrameExtractor frameExtractor;

  @Before
  public void setUpTestId() {
    testId = testName.getMethodName();
  }

  @After
  public void tearDown() {
    if (frameExtractor != null) {
      frameExtractor.release();
    }
  }

  @Test
  public void extractFrame_oneFrame_returnsNearest() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 8_500);
    Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
    Bitmap actualBitmap = frame.bitmap;
    Bitmap expectedBitmap =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "sample_with_increasing_timestamps_360p_8.531.png");
    maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

    assertThat(frame.presentationTimeMs).isEqualTo(8_531);
    assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(2);
  }

  @Test
  public void extractFrame_oneFrameWithPresentationEffect_returnsScaledFrame() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(
        MediaItem.fromUri(FILE_PATH),
        /* effects= */ ImmutableList.of(Presentation.createForHeight(180)));

    ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 8_500);
    Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
    Bitmap actualBitmap = frame.bitmap;
    Bitmap expectedBitmap =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "sample_with_increasing_timestamps_360p_8.531_scaled_to_180p.png");
    maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

    assertThat(frame.presentationTimeMs).isEqualTo(8_531);
    assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(2);
  }

  @Test
  public void extractFrame_pastDuration_returnsLastFrame() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 200_000);
    Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
    Bitmap actualBitmap = frame.bitmap;
    int lastVideoFramePresentationTimeMs = 17_029;
    Bitmap expectedBitmap =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "sample_with_increasing_timestamps_360p_17.029.png");
    maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

    assertThat(frame.presentationTimeMs).isEqualTo(lastVideoFramePresentationTimeMs);
    assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(2);
  }

  @Test
  public void extractFrame_repeatedPositionMs_returnsTheSameFrame() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());
    ImmutableList<Long> requestedFramePositionsMs = ImmutableList.of(0L, 0L, 33L, 34L, 34L);
    ImmutableList<Long> expectedFramePositionsMs = ImmutableList.of(0L, 0L, 33L, 66L, 66L);
    List<ListenableFuture<Frame>> frameFutures = new ArrayList<>();

    for (long positionMs : requestedFramePositionsMs) {
      frameFutures.add(frameExtractor.getFrame(positionMs));
    }
    for (int i = 0; i < expectedFramePositionsMs.size(); i++) {
      ListenableFuture<Frame> frameListenableFuture = frameFutures.get(i);
      Frame frame = frameListenableFuture.get(TIMEOUT_SECONDS, SECONDS);
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual_" + i, frame.bitmap, /* path= */ null);
      Bitmap expectedBitmap =
          readBitmap(
              /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                  + "sample_with_increasing_timestamps_360p_"
                  + String.format(Locale.US, "%.3f", frame.presentationTimeMs / 1000f)
                  + ".png");

      assertBitmapsAreSimilar(expectedBitmap, frame.bitmap, PSNR_THRESHOLD);
      assertThat(frame.presentationTimeMs).isEqualTo(expectedFramePositionsMs.get(i));
    }
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(3);
  }

  @Test
  public void extractFrame_repeatedPositionMsAndClosestSync_returnsTheSameFrame() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context,
            new ExperimentalFrameExtractor.Configuration.Builder()
                .setSeekParameters(CLOSEST_SYNC)
                .build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());
    ImmutableList<Long> requestedFramePositionsMs = ImmutableList.of(0L, 0L, 33L, 34L, 34L);
    ImmutableList<Long> expectedFramePositionsMs = ImmutableList.of(0L, 0L, 0L, 0L, 0L);
    List<ListenableFuture<Frame>> frameFutures = new ArrayList<>();

    for (long positionMs : requestedFramePositionsMs) {
      frameFutures.add(frameExtractor.getFrame(positionMs));
    }
    for (int i = 0; i < expectedFramePositionsMs.size(); i++) {
      ListenableFuture<Frame> frameListenableFuture = frameFutures.get(i);
      Frame frame = frameListenableFuture.get(TIMEOUT_SECONDS, SECONDS);
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual_" + i, frame.bitmap, /* path= */ null);
      Bitmap expectedBitmap =
          readBitmap(
              /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                  + "sample_with_increasing_timestamps_360p_"
                  + String.format(Locale.US, "%.3f", frame.presentationTimeMs / 1000f)
                  + ".png");

      assertBitmapsAreSimilar(expectedBitmap, frame.bitmap, PSNR_THRESHOLD);
      assertThat(frame.presentationTimeMs).isEqualTo(expectedFramePositionsMs.get(i));
    }
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(1);
  }

  @Test
  public void extractFrame_randomAccess_returnsCorrectFrames() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frame5 = frameExtractor.getFrame(/* positionMs= */ 5_000);
    ListenableFuture<Frame> frame3 = frameExtractor.getFrame(/* positionMs= */ 3_000);
    ListenableFuture<Frame> frame7 = frameExtractor.getFrame(/* positionMs= */ 7_000);
    ListenableFuture<Frame> frame2 = frameExtractor.getFrame(/* positionMs= */ 2_000);
    ListenableFuture<Frame> frame8 = frameExtractor.getFrame(/* positionMs= */ 8_000);

    assertThat(frame5.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(5_032);
    assertThat(frame3.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(3_032);
    assertThat(frame7.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(7_031);
    assertThat(frame2.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(2_032);
    assertThat(frame8.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_031);
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(6);
  }

  @Test
  public void extractFrame_closestSyncRandomAccess_returnsCorrectFrames() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context,
            new ExperimentalFrameExtractor.Configuration.Builder()
                .setSeekParameters(CLOSEST_SYNC)
                .build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frame5 = frameExtractor.getFrame(/* positionMs= */ 5_000);
    ListenableFuture<Frame> frame3 = frameExtractor.getFrame(/* positionMs= */ 3_000);
    ListenableFuture<Frame> frame7 = frameExtractor.getFrame(/* positionMs= */ 7_000);
    ListenableFuture<Frame> frame2 = frameExtractor.getFrame(/* positionMs= */ 2_000);
    ListenableFuture<Frame> frame8 = frameExtractor.getFrame(/* positionMs= */ 8_000);

    // The input video has sync points at 0s, 8.331s, and 9.198s. Verify with:
    // ffprobe IN -select_streams v -show_entries frame=pict_type,pts_time -of csv -skip_frame nokey
    assertThat(frame5.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_331);
    assertThat(frame3.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(0);
    assertThat(frame7.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_331);
    assertThat(frame2.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(0);
    assertThat(frame8.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_331);
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(6);
  }

  @Test
  public void extractFrameWithSeekParameters_randomAccess_returnsCorrectFrames() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frame5 = frameExtractor.getFrame(/* positionMs= */ 5_000);
    ListenableFuture<Frame> frame3 = frameExtractor.getFrame(/* positionMs= */ 3_000, CLOSEST_SYNC);
    ListenableFuture<Frame> frame7 = frameExtractor.getFrame(/* positionMs= */ 7_000);
    ListenableFuture<Frame> frame2 = frameExtractor.getFrame(/* positionMs= */ 2_000, NEXT_SYNC);
    ListenableFuture<Frame> frame8 = frameExtractor.getFrame(/* positionMs= */ 8_000, CLOSEST_SYNC);

    assertThat(frame5.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(5_032);
    assertThat(frame3.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(0);
    assertThat(frame7.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(7_031);
    assertThat(frame2.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_331);
    assertThat(frame8.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_331);
    // The last two frames resolve to the same position - only 5 frames are rendered.
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(5);
  }

  @Test
  public void extractFrame_invalidInput_reportsErrorViaFuture() {
    String filePath = "asset:///nonexistent";
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(filePath), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frame0 = frameExtractor.getFrame(/* positionMs= */ 0);

    ExecutionException thrown =
        assertThrows(ExecutionException.class, () -> frame0.get(TIMEOUT_SECONDS, SECONDS));
    assertThat(thrown).hasCauseThat().isInstanceOf(ExoPlaybackException.class);
    assertThat(((ExoPlaybackException) thrown.getCause()).errorCode)
        .isEqualTo(ERROR_CODE_IO_FILE_NOT_FOUND);
  }

  @Test
  public void getFrame_withoutMediaItem_throws() {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());

    ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 8_500);

    ExecutionException thrown =
        assertThrows(ExecutionException.class, () -> frameFuture.get(TIMEOUT_SECONDS, SECONDS));
    assertThat(thrown).hasCauseThat().isInstanceOf(PlaybackException.class);
    assertThat(((PlaybackException) thrown.getCause()).errorCode)
        .isEqualTo(ERROR_CODE_SETUP_REQUIRED);
  }

  @Test
  public void extractFrame_oneFrame_completesViaCallback() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());
    AtomicReference<@NullableType Frame> frameAtomicReference = new AtomicReference<>();
    AtomicReference<@NullableType Throwable> throwableAtomicReference = new AtomicReference<>();
    ConditionVariable frameReady = new ConditionVariable();

    ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 0);
    Futures.addCallback(
        frameFuture,
        new FutureCallback<Frame>() {
          @Override
          public void onSuccess(Frame result) {
            frameAtomicReference.set(result);
            frameReady.open();
          }

          @Override
          public void onFailure(Throwable t) {
            throwableAtomicReference.set(t);
            frameReady.open();
          }
        },
        directExecutor());
    frameReady.block(/* timeoutMs= */ TIMEOUT_SECONDS * 1000);

    assertThat(throwableAtomicReference.get()).isNull();
    assertThat(frameAtomicReference.get().presentationTimeMs).isEqualTo(0);
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(1);
  }

  @Test
  public void frameExtractor_releaseOnPlayerLooper_returns() {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());

    Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
    instrumentation.runOnMainSync(frameExtractor::release);
    frameExtractor = null;
  }

  @Test
  public void extractFrame_oneFrameRotated_returnsFrameInCorrectOrientation() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(
        MediaItem.fromUri(MP4_TRIM_OPTIMIZATION_270.uri), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 0);
    Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
    Bitmap actualBitmap = frame.bitmap;
    Bitmap expectedBitmap =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "internal_emulator_transformer_output_180_rotated_0.000.png");
    maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

    assertThat(frame.presentationTimeMs).isEqualTo(0);
    assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(1);
  }

  @Test
  public void extractFrame_randomAccessWithCancellation_returnsCorrectFrames() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frame5 = frameExtractor.getFrame(/* positionMs= */ 5_000);
    ListenableFuture<Frame> frame3 = frameExtractor.getFrame(/* positionMs= */ 3_000);
    ListenableFuture<Frame> frame7 = frameExtractor.getFrame(/* positionMs= */ 7_000);
    ListenableFuture<Frame> frame2 = frameExtractor.getFrame(/* positionMs= */ 2_000);
    ListenableFuture<Frame> frame8 = frameExtractor.getFrame(/* positionMs= */ 8_000);
    frame5.cancel(/* mayInterruptIfRunning= */ false);
    frame7.cancel(/* mayInterruptIfRunning= */ false);

    assertThat(frame3.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(3_032);
    assertThat(frame2.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(2_032);
    assertThat(frame8.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_031);
    assertThrows(CancellationException.class, () -> frame5.get(TIMEOUT_SECONDS, SECONDS));
    assertThrows(CancellationException.class, () -> frame7.get(TIMEOUT_SECONDS, SECONDS));
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .renderedOutputBufferCount)
        .isEqualTo(4);
  }

  @Test
  public void extractFrame_changeMediaItem_extractsFrameFromTheCorrectItem() throws Exception {
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(
        MediaItem.fromUri(MP4_TRIM_OPTIMIZATION_270.uri), /* effects= */ ImmutableList.of());
    ListenableFuture<Frame> frameFutureFirstItem = frameExtractor.getFrame(/* positionMs= */ 0);
    frameExtractor.setMediaItem(MediaItem.fromUri(FILE_PATH), /* effects= */ ImmutableList.of());
    ListenableFuture<Frame> frameFutureSecondItem =
        frameExtractor.getFrame(/* positionMs= */ 8_500);

    Frame frameFirstItem = frameFutureFirstItem.get(TIMEOUT_SECONDS, SECONDS);
    Bitmap actualBitmapFirstItem = frameFirstItem.bitmap;
    Bitmap expectedBitmapFirstItem =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "internal_emulator_transformer_output_180_rotated_0.000.png");
    maybeSaveTestBitmap(
        testId, /* bitmapLabel= */ "firstItem", actualBitmapFirstItem, /* path= */ null);
    Frame frameSecondItem = frameFutureSecondItem.get(TIMEOUT_SECONDS, SECONDS);
    Bitmap actualBitmapSecondItem = frameSecondItem.bitmap;
    Bitmap expectedBitmapSecondItem =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "sample_with_increasing_timestamps_360p_8.531.png");
    maybeSaveTestBitmap(
        testId, /* bitmapLabel= */ "secondItem", actualBitmapSecondItem, /* path= */ null);

    assertThat(frameFirstItem.presentationTimeMs).isEqualTo(0);
    assertBitmapsAreSimilar(expectedBitmapFirstItem, actualBitmapFirstItem, PSNR_THRESHOLD);
    assertThat(frameSecondItem.presentationTimeMs).isEqualTo(8_531);
    assertBitmapsAreSimilar(expectedBitmapSecondItem, actualBitmapSecondItem, PSNR_THRESHOLD);
  }

  @Test
  public void extractFrame_oneFrame_decodesReferenceFramesOnly() throws Exception {
    assumeFormatsSupported(
        context, testId, /* inputFormat= */ MP4_ASSET.videoFormat, /* outputFormat= */ null);
    frameExtractor =
        new ExperimentalFrameExtractor(
            context, new ExperimentalFrameExtractor.Configuration.Builder().build());
    frameExtractor.setMediaItem(
        MediaItem.fromUri(MP4_ASSET.uri), /* effects= */ ImmutableList.of());

    ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 967);
    Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);

    assertThat(frame.presentationTimeMs).isEqualTo(967);
    assertThat(
            frameExtractor
                .getDecoderCounters()
                .get(TIMEOUT_SECONDS, SECONDS)
                .skippedInputBufferCount)
        .isEqualTo(13);
  }
}
