/*
 * Copyright 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package androidx.media3.inspector.frame;

import static androidx.media3.common.PlaybackException.ERROR_CODE_IO_FILE_NOT_FOUND;
import static androidx.media3.exoplayer.SeekParameters.CLOSEST_SYNC;
import static androidx.media3.test.utils.AssetInfo.MP4_ASSET;
import static androidx.media3.test.utils.AssetInfo.MP4_ONLY_PREROLL_SYNC_SAMPLE_EDIT_LIST;
import static androidx.media3.test.utils.AssetInfo.MP4_TRIM_OPTIMIZATION_270;
import static androidx.media3.test.utils.BitmapPixelTestUtil.maybeSaveTestBitmap;
import static androidx.media3.test.utils.BitmapPixelTestUtil.readBitmap;
import static androidx.media3.test.utils.FormatSupportAssumptions.assumeFormatsSupported;
import static androidx.media3.test.utils.TestUtil.assertBitmapsAreSimilar;
import static com.google.common.truth.Truth.assertThat;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.junit.Assert.assertThrows;

import android.app.Instrumentation;
import android.content.Context;
import android.graphics.Bitmap;
import androidx.media3.common.GlObjectsProvider;
import androidx.media3.common.GlTextureInfo;
import androidx.media3.common.MediaItem;
import androidx.media3.common.VideoFrameProcessingException;
import androidx.media3.common.util.ConditionVariable;
import androidx.media3.common.util.NullableType;
import androidx.media3.effect.DefaultGlObjectsProvider;
import androidx.media3.effect.GlEffect;
import androidx.media3.effect.GlShaderProgram;
import androidx.media3.effect.PassthroughShaderProgram;
import androidx.media3.effect.Presentation;
import androidx.media3.exoplayer.DecoderCounters;
import androidx.media3.exoplayer.ExoPlaybackException;
import androidx.media3.exoplayer.drm.DrmSessionManagerProvider;
import androidx.media3.exoplayer.source.DefaultMediaSourceFactory;
import androidx.media3.exoplayer.source.MediaSource;
import androidx.media3.exoplayer.upstream.LoadErrorHandlingPolicy;
import androidx.media3.extractor.DefaultExtractorsFactory;
import androidx.media3.inspector.frame.FrameExtractor.Frame;
import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import com.google.common.collect.ImmutableList;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

/** End-to-end instrumentation test for {@link FrameExtractor}. */
@RunWith(AndroidJUnit4.class)
public class FrameExtractorTest {
  // Golden files are generated by MediaMetadataRetriever running on Pixel 8.
  private static final String GOLDEN_ASSET_FOLDER_PATH =
      "test-generated-goldens/FrameExtractorTest/";
  private static final String FILE_PATH =
      "asset:///media/mp4/sample_with_increasing_timestamps_360p.mp4";
  private static final long TIMEOUT_SECONDS = 20;
  // TODO: b/350498258 - Due to bugs in hardware decoders, we can only assert for low PSNR values.
  // Move to using software decoders in pixel tests, and increase PSNR threshold.
  private static final float PSNR_THRESHOLD = 25f;

  @Rule public final TestName testName = new TestName();

  private final Context context = ApplicationProvider.getApplicationContext();

  private String testId;

  @Before
  public void setUpTestId() {
    testId = testName.getMethodName();
  }

  @Test
  public void extractFrame_oneFrame_returnsNearest() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 8_500);
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
      Bitmap actualBitmap = frame.bitmap;
      Bitmap expectedBitmap =
          readBitmap(
              /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                  + "sample_with_increasing_timestamps_360p_8.531.png");
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

      assertThat(frame.presentationTimeMs).isEqualTo(8_531);
      assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(2);
    }
  }

  @Test
  public void extractFrame_oneFrameWithPresentationEffect_returnsScaledFrame() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH))
            .setEffects(ImmutableList.of(Presentation.createForHeight(180)))
            .build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 8_500);
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
      Bitmap actualBitmap = frame.bitmap;
      Bitmap expectedBitmap =
          readBitmap(
              /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                  + "sample_with_increasing_timestamps_360p_8.531_scaled_to_180p.png");
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

      assertThat(frame.presentationTimeMs).isEqualTo(8_531);
      assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(2);
    }
  }

  @Test
  public void extractFrame_pastDuration_returnsLastFrame() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 200_000);
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
      Bitmap actualBitmap = frame.bitmap;
      int lastVideoFramePresentationTimeMs = 17_029;
      Bitmap expectedBitmap =
          readBitmap(
              /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                  + "sample_with_increasing_timestamps_360p_17.029.png");
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

      assertThat(frame.presentationTimeMs).isEqualTo(lastVideoFramePresentationTimeMs);
      assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(2);
    }
  }

  @Test
  public void extractFrame_repeatedPositionMs_returnsTheSameFrame() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ImmutableList<Long> requestedFramePositionsMs = ImmutableList.of(0L, 0L, 33L, 34L, 34L);
      ImmutableList<Long> expectedFramePositionsMs = ImmutableList.of(0L, 0L, 33L, 66L, 66L);
      List<ListenableFuture<Frame>> frameFutures = new ArrayList<>();

      for (long positionMs : requestedFramePositionsMs) {
        frameFutures.add(frameExtractor.getFrame(positionMs));
      }
      for (int i = 0; i < expectedFramePositionsMs.size(); i++) {
        ListenableFuture<Frame> frameListenableFuture = frameFutures.get(i);
        Frame frame = frameListenableFuture.get(TIMEOUT_SECONDS, SECONDS);
        maybeSaveTestBitmap(
            testId, /* bitmapLabel= */ "actual_" + i, frame.bitmap, /* path= */ null);
        Bitmap expectedBitmap =
            readBitmap(
                /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                    + "sample_with_increasing_timestamps_360p_"
                    + String.format(Locale.US, "%.3f", frame.presentationTimeMs / 1000f)
                    + ".png");

        assertBitmapsAreSimilar(expectedBitmap, frame.bitmap, PSNR_THRESHOLD);
        assertThat(frame.presentationTimeMs).isEqualTo(expectedFramePositionsMs.get(i));
      }
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(3);
    }
  }

  @Test
  public void extractFrame_repeatedPositionMsAndClosestSync_returnsTheSameFrame() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH))
            .setSeekParameters(CLOSEST_SYNC)
            .build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ImmutableList<Long> requestedFramePositionsMs = ImmutableList.of(0L, 0L, 33L, 34L, 34L);
      ImmutableList<Long> expectedFramePositionsMs = ImmutableList.of(0L, 0L, 0L, 0L, 0L);
      List<ListenableFuture<Frame>> frameFutures = new ArrayList<>();

      for (long positionMs : requestedFramePositionsMs) {
        frameFutures.add(frameExtractor.getFrame(positionMs));
      }
      for (int i = 0; i < expectedFramePositionsMs.size(); i++) {
        ListenableFuture<Frame> frameListenableFuture = frameFutures.get(i);
        Frame frame = frameListenableFuture.get(TIMEOUT_SECONDS, SECONDS);
        maybeSaveTestBitmap(
            testId, /* bitmapLabel= */ "actual_" + i, frame.bitmap, /* path= */ null);
        Bitmap expectedBitmap =
            readBitmap(
                /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                    + "sample_with_increasing_timestamps_360p_"
                    + String.format(Locale.US, "%.3f", frame.presentationTimeMs / 1000f)
                    + ".png");

        assertBitmapsAreSimilar(expectedBitmap, frame.bitmap, PSNR_THRESHOLD);
        assertThat(frame.presentationTimeMs).isEqualTo(expectedFramePositionsMs.get(i));
      }
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(1);
    }
  }

  @Test
  public void extractFrame_randomAccess_returnsCorrectFrames() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frame5 = frameExtractor.getFrame(/* positionMs= */ 5_000);
      ListenableFuture<Frame> frame3 = frameExtractor.getFrame(/* positionMs= */ 3_000);
      ListenableFuture<Frame> frame7 = frameExtractor.getFrame(/* positionMs= */ 7_000);
      ListenableFuture<Frame> frame2 = frameExtractor.getFrame(/* positionMs= */ 2_000);
      ListenableFuture<Frame> frame8 = frameExtractor.getFrame(/* positionMs= */ 8_000);

      assertThat(frame5.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(5_032);
      assertThat(frame3.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(3_032);
      assertThat(frame7.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(7_031);
      assertThat(frame2.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(2_032);
      assertThat(frame8.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_031);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(6);
    }
  }

  @Test
  public void extractFrame_closestSyncRandomAccess_returnsCorrectFrames() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH))
            .setSeekParameters(CLOSEST_SYNC)
            .build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frame5 = frameExtractor.getFrame(/* positionMs= */ 5_000);
      ListenableFuture<Frame> frame3 = frameExtractor.getFrame(/* positionMs= */ 3_000);
      ListenableFuture<Frame> frame7 = frameExtractor.getFrame(/* positionMs= */ 7_000);
      ListenableFuture<Frame> frame2 = frameExtractor.getFrame(/* positionMs= */ 2_000);
      ListenableFuture<Frame> frame8 = frameExtractor.getFrame(/* positionMs= */ 8_000);

      // The input video has sync points at 0s, 8.331s, and 9.198s. Verify with:
      // ffprobe IN -select_streams v -show_entries frame=pict_type,pts_time -of csv -skip_frame
      // nokey
      assertThat(frame5.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_331);
      assertThat(frame3.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(0);
      assertThat(frame7.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_331);
      assertThat(frame2.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(0);
      assertThat(frame8.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_331);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(6);
    }
  }

  @Test
  public void extractFrame_invalidInput_reportsErrorViaFuture() {
    String filePath = "asset:///nonexistent";
    Exception thrown =
        assertThrows(
            Exception.class,
            () -> {
              try (FrameExtractor frameExtractor =
                  new FrameExtractor.Builder(context, MediaItem.fromUri(filePath)).build()) {
                frameExtractor.getFrame(/* positionMs= */ 0).get(TIMEOUT_SECONDS, SECONDS);
              }
            });
    assertThat(thrown).isInstanceOf(ExecutionException.class);
    assertThat(thrown).hasCauseThat().isInstanceOf(ExoPlaybackException.class);
    assertThat(((ExoPlaybackException) thrown.getCause()).errorCode)
        .isEqualTo(ERROR_CODE_IO_FILE_NOT_FOUND);
  }

  @Test
  public void extractFrame_oneFrame_completesViaCallback() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      AtomicReference<@NullableType Frame> frameAtomicReference = new AtomicReference<>();
      AtomicReference<@NullableType Throwable> throwableAtomicReference = new AtomicReference<>();
      ConditionVariable frameReady = new ConditionVariable();

      ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 0);
      Futures.addCallback(
          frameFuture,
          new FutureCallback<Frame>() {
            @Override
            public void onSuccess(Frame result) {
              frameAtomicReference.set(result);
              frameReady.open();
            }

            @Override
            public void onFailure(Throwable t) {
              throwableAtomicReference.set(t);
              frameReady.open();
            }
          },
          directExecutor());
      frameReady.block(/* timeoutMs= */ TIMEOUT_SECONDS * 1000);

      assertThat(throwableAtomicReference.get()).isNull();
      assertThat(frameAtomicReference.get().presentationTimeMs).isEqualTo(0);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(1);
    }
  }

  @Test
  public void frameExtractor_releaseOnPlayerLooper_returns() {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
      instrumentation.runOnMainSync(frameExtractor::close);
    }
  }

  @Test
  public void extractFrame_oneFrameRotated_returnsFrameInCorrectOrientation() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(MP4_TRIM_OPTIMIZATION_270.uri))
            .build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 0);
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
      Bitmap actualBitmap = frame.bitmap;
      Bitmap expectedBitmap =
          readBitmap(
              /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                  + "internal_emulator_transformer_output_180_rotated_0.000.png");
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

      assertThat(frame.presentationTimeMs).isEqualTo(0);
      assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(1);
    }
  }

  @Test
  public void extractFrame_randomAccessWithCancellation_returnsCorrectFrames() throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frame3 = frameExtractor.getFrame(/* positionMs= */ 3_000);
      ListenableFuture<Frame> frame5 = frameExtractor.getFrame(/* positionMs= */ 5_000);
      ListenableFuture<Frame> frame7 = frameExtractor.getFrame(/* positionMs= */ 7_000);
      ListenableFuture<Frame> frame2 = frameExtractor.getFrame(/* positionMs= */ 2_000);
      ListenableFuture<Frame> frame8 = frameExtractor.getFrame(/* positionMs= */ 8_000);
      frame5.cancel(/* mayInterruptIfRunning= */ false);
      frame7.cancel(/* mayInterruptIfRunning= */ false);

      assertThat(frame3.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(3_032);
      assertThat(frame2.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(2_032);
      assertThat(frame8.get(TIMEOUT_SECONDS, SECONDS).presentationTimeMs).isEqualTo(8_031);
      assertThrows(CancellationException.class, () -> frame5.get(TIMEOUT_SECONDS, SECONDS));
      assertThrows(CancellationException.class, () -> frame7.get(TIMEOUT_SECONDS, SECONDS));
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int renderedOutputBufferCount =
          finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount;
      assertThat(renderedOutputBufferCount).isAtMost(4);
    }
  }

  @Test
  public void extractFrame_changeMediaItem_extractsFrameFromTheCorrectItem() throws Exception {
    Frame frameFirstItem;
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(MP4_TRIM_OPTIMIZATION_270.uri))
            .build()) {
      ListenableFuture<Frame> frameFutureFirstItem = frameExtractor.getFrame(/* positionMs= */ 0);
      frameFirstItem = frameFutureFirstItem.get(TIMEOUT_SECONDS, SECONDS);
    }

    Frame frameSecondItem;
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      ListenableFuture<Frame> frameFutureSecondItem =
          frameExtractor.getFrame(/* positionMs= */ 8_500);
      frameSecondItem = frameFutureSecondItem.get(TIMEOUT_SECONDS, SECONDS);
    }

    Bitmap actualBitmapFirstItem = frameFirstItem.bitmap;
    Bitmap expectedBitmapFirstItem =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "internal_emulator_transformer_output_180_rotated_0.000.png");
    maybeSaveTestBitmap(
        testId, /* bitmapLabel= */ "firstItem", actualBitmapFirstItem, /* path= */ null);
    Bitmap actualBitmapSecondItem = frameSecondItem.bitmap;
    Bitmap expectedBitmapSecondItem =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "sample_with_increasing_timestamps_360p_8.531.png");
    maybeSaveTestBitmap(
        testId, /* bitmapLabel= */ "secondItem", actualBitmapSecondItem, /* path= */ null);

    assertThat(frameFirstItem.presentationTimeMs).isEqualTo(0);
    assertBitmapsAreSimilar(expectedBitmapFirstItem, actualBitmapFirstItem, PSNR_THRESHOLD);
    assertThat(frameSecondItem.presentationTimeMs).isEqualTo(8_531);
    assertBitmapsAreSimilar(expectedBitmapSecondItem, actualBitmapSecondItem, PSNR_THRESHOLD);
  }

  @Test
  public void extractFrame_oneFrame_decodesReferenceFramesOnly() throws Exception {
    assumeFormatsSupported(
        context, testId, /* inputFormat= */ MP4_ASSET.videoFormat, /* outputFormat= */ null);
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(MP4_ASSET.uri)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialSkippedInputBufferCount =
          initialCounters != null ? initialCounters.skippedInputBufferCount : 0;
      ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 967);
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);

      assertThat(frame.presentationTimeMs).isEqualTo(967);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.skippedInputBufferCount - initialSkippedInputBufferCount)
          .isEqualTo(13);
    }
  }

  @Test
  public void extractFrame_withGlObjectsProvider_usesCustomObjectsProvider() throws Exception {
    GlObjectsProvider customObjectsProvider = new DefaultGlObjectsProvider();
    AtomicReference<GlObjectsProvider> glObjectsProviderUsedByEffects = new AtomicReference<>();
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH))
            .setGlObjectsProvider(customObjectsProvider)
            .setEffects(
                ImmutableList.of(
                    new GlEffect() {
                      @Override
                      public GlShaderProgram toGlShaderProgram(Context context, boolean useHdr) {
                        return new PassthroughShaderProgram() {
                          @Override
                          public void queueInputFrame(
                              GlObjectsProvider glObjectsProvider,
                              GlTextureInfo inputTexture,
                              long presentationTimeUs) {
                            glObjectsProviderUsedByEffects.set(glObjectsProvider);
                            super.queueInputFrame(
                                glObjectsProvider, inputTexture, presentationTimeUs);
                          }
                        };
                      }
                    }))
            .build()) {
      ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 8_500);
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);

      assertThat(frame.presentationTimeMs).isEqualTo(8_531);
      assertThat(glObjectsProviderUsedByEffects.get()).isEqualTo(customObjectsProvider);
    }
  }

  @Test
  public void extractFrame_withCustomMediaSourceFactory_usesFactory() throws Exception {
    AtomicBoolean factoryUsed = new AtomicBoolean(false);
    MediaItem mediaItem = MediaItem.fromUri(FILE_PATH);
    MediaSource.Factory customMediaSourceFactory =
        new MediaSource.Factory() {
          private final MediaSource.Factory delegate =
              new DefaultMediaSourceFactory(context, new DefaultExtractorsFactory());

          @Override
          public MediaSource.Factory setDrmSessionManagerProvider(
              DrmSessionManagerProvider drmSessionManagerProvider) {
            delegate.setDrmSessionManagerProvider(drmSessionManagerProvider);
            return this;
          }

          @Override
          public MediaSource.Factory setLoadErrorHandlingPolicy(
              LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
            delegate.setLoadErrorHandlingPolicy(loadErrorHandlingPolicy);
            return this;
          }

          @Override
          public int[] getSupportedTypes() {
            return delegate.getSupportedTypes();
          }

          @Override
          public MediaSource createMediaSource(MediaItem mediaItem) {
            factoryUsed.set(true);
            return delegate.createMediaSource(mediaItem);
          }
        };

    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, mediaItem)
            .setMediaSourceFactory(customMediaSourceFactory)
            .build()) {
      ListenableFuture<Frame> frameFuture = frameExtractor.getFrame(/* positionMs= */ 0);
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
      assertThat(frame).isNotNull();
      assertThat(frame.bitmap).isNotNull();
    }

    assertThat(factoryUsed.get()).isTrue();
  }

  @Test
  public void extractFrame_onNonLooperThread_returnsFrame() throws Exception {
    AtomicReference<Frame> frame = new AtomicReference<>();

    Thread nonLooperThread =
        new Thread(
            () -> {
              try (FrameExtractor frameExtractor =
                  new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
                ListenableFuture<Frame> frameFuture =
                    frameExtractor.getFrame(/* positionMs= */ 8_500);
                frame.set(frameFuture.get(TIMEOUT_SECONDS, SECONDS));
              } catch (InterruptedException | ExecutionException | TimeoutException e) {
                throw new IllegalStateException(e);
              }
            });
    nonLooperThread.start();
    nonLooperThread.join();

    Bitmap actualBitmap = frame.get().bitmap;
    Bitmap expectedBitmap =
        readBitmap(
            /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                + "sample_with_increasing_timestamps_360p_8.531.png");
    maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);
    assertThat(frame.get().presentationTimeMs).isEqualTo(8_531);
    assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
  }

  @Test
  public void extractThumbnail_whenThumbnailMetadataTimestampIsZero_returnsCorrectFrame()
      throws Exception {
    assumeFormatsSupported(
        context, testId, /* inputFormat= */ MP4_ASSET.videoFormat, /* outputFormat= */ null);
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(MP4_ASSET.uri)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frameFuture = frameExtractor.getThumbnail();
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
      Bitmap actualBitmap = frame.bitmap;
      Bitmap expectedBitmap =
          readBitmap(/* assetString= */ GOLDEN_ASSET_FOLDER_PATH + "sample_0.000.png");
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

      assertThat(frame.presentationTimeMs).isEqualTo(0);
      assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(1);
    }
  }

  @Test
  public void extractThumbnail_whenThumbnailMetadataTimestampIsNonZero_returnsCorrectFrame()
      throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH)).build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frameFuture = frameExtractor.getThumbnail();
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
      Bitmap actualBitmap = frame.bitmap;
      Bitmap expectedBitmap =
          readBitmap(
              /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                  + "sample_with_increasing_timestamps_360p_8.331.png");
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

      assertThat(frame.presentationTimeMs).isEqualTo(8_331);
      assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(2);
    }
  }

  @Test
  public void extractThumbnail_whenThumbnailMetadataIsMissing_returnsCorrectFrame()
      throws Exception {
    try (FrameExtractor frameExtractor =
        new FrameExtractor.Builder(
                context, MediaItem.fromUri(MP4_ONLY_PREROLL_SYNC_SAMPLE_EDIT_LIST.uri))
            .build()) {
      DecoderCounters initialCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      int initialRenderedOutputBufferCount =
          initialCounters != null ? initialCounters.renderedOutputBufferCount : 0;
      ListenableFuture<Frame> frameFuture = frameExtractor.getThumbnail();
      Frame frame = frameFuture.get(TIMEOUT_SECONDS, SECONDS);
      Bitmap actualBitmap = frame.bitmap;
      Bitmap expectedBitmap =
          readBitmap(
              /* assetString= */ GOLDEN_ASSET_FOLDER_PATH
                  + "sample_edit_list_only_preroll_sync_sample_0.000.png");
      maybeSaveTestBitmap(testId, /* bitmapLabel= */ "actual", actualBitmap, /* path= */ null);

      assertThat(frame.presentationTimeMs).isEqualTo(0);
      assertBitmapsAreSimilar(expectedBitmap, actualBitmap, PSNR_THRESHOLD);
      DecoderCounters finalCounters =
          frameExtractor.getDecoderCounters().get(TIMEOUT_SECONDS, SECONDS);
      assertThat(finalCounters.renderedOutputBufferCount - initialRenderedOutputBufferCount)
          .isAtMost(1);
    }
  }

  @Test
  public void extractFrame_withFailingEffect_reportsErrorViaFuture() {
    ExecutionException thrown =
        assertThrows(
            ExecutionException.class,
            () -> {
              try (FrameExtractor frameExtractor =
                  new FrameExtractor.Builder(context, MediaItem.fromUri(FILE_PATH))
                      .setEffects(
                          ImmutableList.of(
                              (GlEffect)
                                  (context, useHdr) ->
                                      new PassthroughShaderProgram() {
                                        @Override
                                        public void queueInputFrame(
                                            GlObjectsProvider glObjectsProvider,
                                            GlTextureInfo inputTexture,
                                            long presentationTimeUs) {
                                          onError(
                                              new VideoFrameProcessingException(
                                                  "Simulated processing failure"));
                                        }
                                      }))
                      .build()) {
                frameExtractor.getFrame(/* positionMs= */ 0).get(TIMEOUT_SECONDS, SECONDS);
              }
            });

    assertThat(thrown).hasCauseThat().isInstanceOf(ExoPlaybackException.class);
  }
}
